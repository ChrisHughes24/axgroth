import Mathlib

open Topology

lemma tendsto_inv_cobounded {ùïú : Type*} [NormedDivisionRing ùïú] :
    Filter.Tendsto (.‚Åª¬π) (ùìù[‚â†] (0 : ùïú)) (Bornology.cobounded ùïú) := by
  simp [Filter.Tendsto]

lemma thing {Œπ : Type*} [Fintype Œπ] [Nonempty Œπ] (f : (Œπ ‚Üí ‚ÑÇ) ‚âÉ (Œπ ‚Üí ‚ÑÇ)) (hf : Continuous f)
    {s : Set (Œπ ‚Üí ‚ÑÇ)} (hs : Dense (f ‚Åª¬π' s)) {x : Œπ ‚Üí ‚ÑÇ}
    (hg : Filter.Tendsto f.symm (ùìù[s] x) (Filter.cocompact _)) : False := by
  have : Filter.Tendsto f (ùìù[f ‚Åª¬π' s] (f.symm x)) (ùìù[s] f (f.symm x)) :=
    tendsto_nhdsWithin_iff.2 ‚ü®hf.continuousAt.mono_left nhdsWithin_le_nhds,
        eventually_nhdsWithin_of_forall <| by simp‚ü©
  simp only [Equiv.apply_symm_apply] at this
  have : Filter.Tendsto (fun x => x) (ùìù[f ‚Åª¬π' s] f.symm x) (Filter.cocompact _) := by
    simpa using hg.comp this
  simp only [Filter.Tendsto, Filter.map_id', Filter.le_def, Filter.mem_cocompact, mem_nhdsWithin,
    forall_exists_index, and_imp] at this
  rcases this (Metric.closedBall (f.symm x) 1)·∂ú (Metric.closedBall (f.symm x) 1)
    (by exact isCompact_closedBall (f.symm x) 1) (fun _ a => a) with ‚ü®U, hU‚ü©
  rcases Metric.isOpen_iff.1 hU.1 (f.symm x) hU.2.1 with ‚ü®Œµ, Œµ0, hŒµ‚ü©
  rcases hs.exists_mem_open Metric.isOpen_ball
    ‚ü®f.symm x, show f.symm x ‚àà Metric.ball (f.symm x) (min Œµ 1) by simp [Œµ0]‚ü© with ‚ü®y, hy‚ü©
  have h1 := hU.2.2 (Set.mem_inter (hŒµ (Metric.ball_subset_ball (by simp) hy.2)) hy.1)
  have h2 := hy.2
  simp only [Set.mem_compl_iff, Metric.mem_closedBall, not_le, Metric.mem_ball, lt_inf_iff] at h1 h2
  linarith

lemma thing' (f : ‚ÑÇ ‚âÉ ‚ÑÇ) (hf : Continuous f) (x : ‚ÑÇ)
    (hg : Filter.Tendsto f.symm (ùìù[‚â†] x) (Filter.cocompact _)) : False := by
  have : Filter.Tendsto f (ùìù[‚â†] (f.symm x)) (ùìù[‚â†] f (f.symm x)) :=
    tendsto_nhdsWithin_iff.2 ‚ü®hf.continuousAt.mono_left nhdsWithin_le_nhds,
        eventually_nhdsWithin_of_forall <| by simp +contextual [not_imp_not, eq_comm]‚ü©
  simp only [Equiv.apply_symm_apply] at this
  have : Filter.Tendsto (fun x => x) (ùìù[‚â†] f.symm x) (Filter.cocompact _) := by
    simpa using hg.comp this
  simp only [Filter.Tendsto, Filter.map_id', Filter.le_def, Filter.mem_cocompact, mem_nhdsWithin,
    forall_exists_index, and_imp] at this
  rcases this (Metric.closedBall (f.symm x) 1)·∂ú (Metric.closedBall (f.symm x) 1)
    (by exact isCompact_closedBall (f.symm x) 1) (fun _ a => a) with ‚ü®U, hU‚ü©
  rcases Metric.isOpen_iff.1 hU.1 (f.symm x) hU.2.1 with ‚ü®Œµ, Œµ0, hŒµ‚ü©
  have : f.symm x + (‚Üë(min (1 : ‚Ñù) (Œµ / 2)) : ‚ÑÇ) ‚àà Metric.ball (f.symm x) Œµ := by
    simp [abs_of_nonneg (le_min zero_le_one (le_of_lt (half_pos Œµ0))), Œµ0]
  have := hU.2.2 (Set.mem_inter (hŒµ this) (by simp [ne_of_gt Œµ0, min_eq_iff]))
  simp [abs_of_nonneg (le_min zero_le_one (le_of_lt (half_pos Œµ0)))] at this

lemma eq_zero_of_eqOn_nonempty_open {Œπ : Type*} (p : MvPolynomial Œπ ‚ÑÇ) (U : Set (Œπ ‚Üí ‚ÑÇ))
    (hU : U.Nonempty) (u_open : IsOpen U) (U0 : ‚àÄ x ‚àà U, p.eval x = 0) : p = 0 := by
  rw [isOpen_pi_iff] at u_open
  rcases hU with ‚ü®x, hx‚ü©
  rcases u_open x hx with ‚ü®H, u, hIu‚ü©
  let v : Œπ ‚Üí Set ‚ÑÇ := fun i => by classical exact if i ‚àà H then u i else Set.univ
  exact MvPolynomial.funext_set v (p := p) (q := 0)
    (by
      intro i
      simp only [v]
      split_ifs with hH
      ¬∑ refine infinite_of_mem_nhds (x i) ?_
        rw [mem_nhds_iff]
        use u i
        simp [hIu.1 i hH]
      ¬∑ exact Set.infinite_univ)
    (by
      intro y hy
      simp at hy
      simp only [map_zero]
      apply U0
      apply hIu.2
      simp
      intro i Hi
      simp [v] at hy
      exact hy i Hi)

lemma dense_zero {Œπ : Type*} {p : MvPolynomial Œπ ‚ÑÇ} (p0 : p ‚â† 0) : Dense { x : Œπ ‚Üí ‚ÑÇ | p.eval x ‚â† 0 } := by
  rw [dense_iff_inter_open]
  intro U u_open u_none
  by_contra h
  simp only [ne_eq, Set.nonempty_iff_ne_empty, Set.ext_iff, Set.mem_inter_iff, Set.mem_setOf_eq,
    Set.mem_empty_iff_false, iff_false, not_and, Decidable.not_not, not_forall, not_exists] at h
  apply p0
  exact eq_zero_of_eqOn_nonempty_open p U u_none u_open h

section MvPolynomial

open MvPolynomial

variable {K L Œπ : Type*} [Field K] [Field L]

lemma injective_iff_mem_radical [Finite Œπ] [Algebra K L] [IsAlgClosed L] {p : Œπ ‚Üí MvPolynomial Œπ K} :
    Function.Injective (fun x i => (aeval x (p i) : L)) ‚Üî
    (‚àÄ i : Œπ, ((.X (Sum.inl i) : MvPolynomial (Œπ ‚äï Œπ) K) - .X (Sum.inr i)) ‚àà
      Ideal.radical (Ideal.span (Set.range (fun i : Œπ => (p i).rename Sum.inl -
        (p i).rename Sum.inr)))) := by
  simp only [Function.Injective, funext_iff, ‚Üê vanishingIdeal_zeroLocus_eq_radical (K := L),
    zeroLocus_span, Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff, map_sub, aeval_rename,
    Function.comp_def, sub_eq_zero, mem_vanishingIdeal_iff, Set.mem_setOf_eq, aeval_X, Sum.forall_sum]
  exact ‚ü®fun h _ _ _ h2 => h h2 _, fun h _ _ h2 _ => h _ _ _ h2‚ü©

lemma bijective_of_injective_on_isAlgClosed [Finite Œπ] [IsAlgClosed L] [Algebra K L] [CharZero K]
    (p : Œπ ‚Üí MvPolynomial Œπ K) (hInj : Function.Injective (fun x i => (aeval x (p i) : L))) :
    Function.Bijective (fun x i => eval x (p i)) := by
  refine ‚ü®?_, ?_‚ü©
  ¬∑ intro x y hxy
    have (x : Œπ ‚Üí K) : (aeval (fun j => algebraMap K L (x j))).toRingHom = (algebraMap K L).comp (eval x) := by ext <;> simp
    replace hInj := @hInj (fun j => algebraMap K L (x j)) (fun j => algebraMap K L (y j))
    simp only [AlgHom.toRingHom_eq_coe, RingHom.ext_iff, RingHom.coe_coe, RingHom.coe_comp,
      Function.comp_apply] at this
    simp only [this, funext_iff, algebraMap.coe_inj] at hInj hxy
    ext
    apply hInj
    exact hxy
  ¬∑ replace hInj : Function.Injective (fun x i => (aeval x (p i) : AlgebraicClosure K)) := by
      simpa only [injective_iff_mem_radical] using hInj
    intro x
    simp only [aeval_def, ‚Üê eval_map] at hInj
    rcases ax_grothendieck_univ (fun i => (p i).map (algebraMap K (AlgebraicClosure K))) hInj
      (fun i => algebraMap _ _ (x i)) with ‚ü®y, hy‚ü©
    simp only [eval_map, ‚Üê aeval_def, funext_iff] at hy
    have : IntermediateField.fixedField (F := K) (E := AlgebraicClosure K) ‚ä§ = ‚ä• :=
      InfiniteGalois.fixedField_bot
    simp only [IntermediateField.ext_iff, IntermediateField.mem_fixedField_iff, Subgroup.mem_top,
      forall_const] at this
    have : ‚àÄ i, y i ‚àà (‚ä• : IntermediateField K (AlgebraicClosure K)) := by
      intro i
      rw [‚Üê this]
      intro f
      have hom_eq : ‚àÄ x : Œπ ‚Üí AlgebraicClosure K,
        aeval (fun i => f (x i)) = f.toAlgHom.comp (aeval x) := by
        intros; ext; simp
      have := @hInj y (fun i => f (y i))
      simp only [eval_map, ‚Üê aeval_def, hy, hom_eq, AlgEquiv.toAlgHom_eq_coe, AlgHom.comp_apply,
        AlgHom.commutes, funext_iff, forall_const] at this
      rw [‚Üê this]
    simp only [IntermediateField.mem_bot, Set.mem_range, Classical.skolem] at this
    rcases this with ‚ü®z, hz‚ü©
    use z
    ext i
    have : (aeval y).toRingHom = (algebraMap K (AlgebraicClosure K)).comp (eval z) := by
      ext
      simp
      simp [‚Üê hz]
    simp only [AlgHom.toRingHom_eq_coe, RingHom.ext_iff, RingHom.coe_coe, RingHom.coe_comp,
      Function.comp_apply] at this
    apply RingHom.injective (algebraMap K (AlgebraicClosure K))
    rw [‚Üê hy, this]

section FractionRing

variable [Algebra K ‚ÑÇ]

def NonZeroDenom (r : FractionRing (MvPolynomial Œπ K)) (x : Œπ ‚Üí ‚ÑÇ) : Prop :=
  ‚àÉ p : MvPolynomial Œπ K √ó MvPolynomial Œπ K,
      r * algebraMap (MvPolynomial Œπ K) (FractionRing (MvPolynomial Œπ K)) p.2 =
      algebraMap (MvPolynomial Œπ K) (FractionRing (MvPolynomial Œπ K)) p.1 ‚àß
      p.2.aeval x ‚â† 0

noncomputable def evalFractionRing (r : FractionRing (MvPolynomial Œπ K)) (x : Œπ ‚Üí ‚ÑÇ) : ‚ÑÇ := by
  classical exact
    if h : NonZeroDenom r x
    then let (p, q) := Classical.choose h; p.aeval x / q.aeval x
    else 0

lemma evalFractionRing_eq_of_eq (r : FractionRing (MvPolynomial Œπ K)) (x : Œπ ‚Üí ‚ÑÇ)
    (p q : MvPolynomial Œπ K)
    (h : r * algebraMap (MvPolynomial Œπ K) (FractionRing (MvPolynomial Œπ K)) q =
      algebraMap (MvPolynomial Œπ K) (FractionRing (MvPolynomial Œπ K)) p)
    (hq : q.aeval x ‚â† 0) :
    evalFractionRing r x = p.aeval x / q.aeval x := by
  rw [evalFractionRing]
  have : ‚àÉ p : MvPolynomial Œπ K √ó MvPolynomial Œπ K,
      r * algebraMap (MvPolynomial Œπ K) (FractionRing (MvPolynomial Œπ K)) p.2 =
      algebraMap (MvPolynomial Œπ K) (FractionRing (MvPolynomial Œπ K)) p.1 ‚àß
      p.2.aeval x ‚â† 0 := ‚ü®(p, q), h, hq‚ü©
  delta NonZeroDenom
  rw [dif_pos this]
  simp only [ne_eq]
  have psec := Classical.choose_spec this
  rw [div_eq_div_iff psec.2 hq]
  rw [‚Üê map_mul, ‚Üê map_mul]
  congr 1
  apply_fun (algebraMap (MvPolynomial Œπ K) (FractionRing (MvPolynomial Œπ K)))
  ¬∑ rw [map_mul, map_mul, ‚Üê psec.1, ‚Üê h]
    simp [mul_comm, mul_assoc, mul_left_comm]
  ¬∑ intro _; simp

@[simp]
lemma evalFractionRing_algebraMap (a : K) (x : Œπ ‚Üí ‚ÑÇ) :
    evalFractionRing (algebraMap K (FractionRing (MvPolynomial Œπ K)) a) x = algebraMap K ‚ÑÇ a := by
  rw [evalFractionRing_eq_of_eq _ x (.C a) 1 (by simp; rfl) (by simp)]
  simp

@[simp]
lemma evalFractionRing_X (x : Œπ ‚Üí ‚ÑÇ) (i : Œπ) :
    evalFractionRing (algebraMap (MvPolynomial Œπ K) (FractionRing (MvPolynomial Œπ K)) (X i)) x = x i := by
  rw [evalFractionRing_eq_of_eq _ x (.X i) 1 (by simp) (by simp)]
  simp

lemma nonZeroDenom_add {r‚ÇÅ r‚ÇÇ : FractionRing (MvPolynomial Œπ K)} {x : Œπ ‚Üí ‚ÑÇ} :
    NonZeroDenom r‚ÇÅ x ‚Üí NonZeroDenom r‚ÇÇ x ‚Üí NonZeroDenom (r‚ÇÅ + r‚ÇÇ) x := by
  rintro ‚ü®‚ü®p‚ÇÅ, q‚ÇÅ‚ü©, h‚ÇÅ‚ü© ‚ü®‚ü®p‚ÇÇ, q‚ÇÇ‚ü©, h‚ÇÇ‚ü©
  use ((p‚ÇÅ * q‚ÇÇ + p‚ÇÇ * q‚ÇÅ), q‚ÇÅ * q‚ÇÇ)
  simp [h‚ÇÅ.2, h‚ÇÇ.2, add_mul]
  rw [‚Üê mul_assoc, h‚ÇÅ.1, ‚Üê mul_assoc, mul_right_comm, h‚ÇÇ.1]

lemma evalFractionRing_add {r‚ÇÅ r‚ÇÇ : FractionRing (MvPolynomial Œπ K)} {x : Œπ ‚Üí ‚ÑÇ} :
    NonZeroDenom r‚ÇÅ x ‚Üí NonZeroDenom r‚ÇÇ x ‚Üí
    evalFractionRing (r‚ÇÅ + r‚ÇÇ) x = evalFractionRing r‚ÇÅ x + evalFractionRing r‚ÇÇ x := by
  rintro ‚ü®‚ü®p‚ÇÅ, q‚ÇÅ‚ü©, h‚ÇÅ‚ü© ‚ü®‚ü®p‚ÇÇ, q‚ÇÇ‚ü©, h‚ÇÇ‚ü©
  have := evalFractionRing_eq_of_eq (r‚ÇÅ + r‚ÇÇ) x (p‚ÇÅ * q‚ÇÇ + p‚ÇÇ * q‚ÇÅ) (q‚ÇÅ * q‚ÇÇ)
  rw [evalFractionRing_eq_of_eq r‚ÇÅ x p‚ÇÅ q‚ÇÅ h‚ÇÅ.1 h‚ÇÅ.2,
    evalFractionRing_eq_of_eq r‚ÇÇ x p‚ÇÇ q‚ÇÇ h‚ÇÇ.1 h‚ÇÇ.2]
  simp only [ne_eq] at h‚ÇÅ h‚ÇÇ
  simp [h‚ÇÅ.2, h‚ÇÇ.2, add_mul] at this
  rw [‚Üê mul_assoc, h‚ÇÅ.1, ‚Üê mul_assoc, mul_right_comm, h‚ÇÇ.1] at this
  replace this := this rfl
  rw [this, div_add_div _ _ (by simp [h‚ÇÅ.2]) (by simp [h‚ÇÇ.2])]
  ring_nf

lemma nonZeroDenom_mul {r‚ÇÅ r‚ÇÇ : FractionRing (MvPolynomial Œπ K)} {x : Œπ ‚Üí ‚ÑÇ} :
    NonZeroDenom r‚ÇÅ x ‚Üí NonZeroDenom r‚ÇÇ x ‚Üí NonZeroDenom (r‚ÇÅ * r‚ÇÇ) x := by
  rintro ‚ü®‚ü®p‚ÇÅ, q‚ÇÅ‚ü©, h‚ÇÅ‚ü© ‚ü®‚ü®p‚ÇÇ, q‚ÇÇ‚ü©, h‚ÇÇ‚ü©
  use (p‚ÇÅ * p‚ÇÇ, q‚ÇÅ * q‚ÇÇ)
  simp [h‚ÇÅ.2, h‚ÇÇ.2]
  rw [‚Üê h‚ÇÅ.1, ‚Üê h‚ÇÇ.1]; ring

lemma evalFractionRing_mul {r‚ÇÅ r‚ÇÇ : FractionRing (MvPolynomial Œπ K)} {x : Œπ ‚Üí ‚ÑÇ} :
    NonZeroDenom r‚ÇÅ x ‚Üí NonZeroDenom r‚ÇÇ x ‚Üí
    evalFractionRing (r‚ÇÅ * r‚ÇÇ) x = evalFractionRing r‚ÇÅ x * evalFractionRing r‚ÇÇ x := by
  rintro ‚ü®‚ü®p‚ÇÅ, q‚ÇÅ‚ü©, h‚ÇÅ‚ü© ‚ü®‚ü®p‚ÇÇ, q‚ÇÇ‚ü©, h‚ÇÇ‚ü©
  have := evalFractionRing_eq_of_eq (r‚ÇÅ * r‚ÇÇ) x (p‚ÇÅ * p‚ÇÇ) (q‚ÇÅ * q‚ÇÇ)
  rw [evalFractionRing_eq_of_eq r‚ÇÅ x p‚ÇÅ q‚ÇÅ h‚ÇÅ.1 h‚ÇÅ.2,
    evalFractionRing_eq_of_eq r‚ÇÇ x p‚ÇÇ q‚ÇÇ h‚ÇÇ.1 h‚ÇÇ.2]
  simp only [ne_eq] at h‚ÇÅ h‚ÇÇ
  simp [h‚ÇÅ.2, h‚ÇÇ.2] at this
  rw [‚Üê h‚ÇÅ.1, ‚Üê h‚ÇÇ.1] at this
  replace this := this (by ring)
  rw [this]
  ring_nf

lemma nonZeroDenom_aeval (p : MvPolynomial Œπ K)
    (r : Œπ ‚Üí FractionRing (MvPolynomial Œπ K)) (x : Œπ ‚Üí ‚ÑÇ)
    (hr : ‚àÄ i, NonZeroDenom (r i) x)  :
    NonZeroDenom (p.aeval r) x := by
  induction p using MvPolynomial.induction_on with
  | C a =>
    use (.C a, 1)
    simp; rfl
  | add p q ihp ihq =>
    rw [map_add]
    exact nonZeroDenom_add ihp ihq
  | mul_X i p ihp =>
    rw [map_mul, aeval_X]
    exact nonZeroDenom_mul ihp (hr p)

lemma evalFractionRing_aeval (p : MvPolynomial Œπ K)
    (r : Œπ ‚Üí FractionRing (MvPolynomial Œπ K)) (x : Œπ ‚Üí ‚ÑÇ)
    (hr : ‚àÄ i, NonZeroDenom (r i) x)  :
    evalFractionRing (p.aeval r) x = p.aeval (fun i => evalFractionRing (r i) x) := by
  induction p using MvPolynomial.induction_on with
  | C a => simp
  | add p q ihp ihq =>
    rw [map_add, map_add, ‚Üê ihp, ‚Üê ihq]
    refine (evalFractionRing_add ?_ ?_)
    ¬∑ exact nonZeroDenom_aeval p r x hr
    ¬∑ exact nonZeroDenom_aeval q r x hr
  | mul_X i p ihp =>
    rw [map_mul, aeval_X, map_mul, aeval_X, ‚Üê ihp]
    refine evalFractionRing_mul ?_ (hr p)
    exact nonZeroDenom_aeval i r x hr

end FractionRing

lemma exists_MvRatFunc_inverse [Finite Œπ] [Algebra K ‚ÑÇ]
    (p : Œπ ‚Üí MvPolynomial Œπ K)
    (hInj : Function.Injective (fun x i => (aeval x (p i) : ‚ÑÇ))) :
    ‚àÉ r : Œπ ‚Üí FractionRing (MvPolynomial Œπ K),
      ‚àÄ (x : Œπ ‚Üí ‚ÑÇ), (‚àÄ i, NonZeroDenom (r i) x) ‚Üí
      ‚àÄ i, (p i).aeval (fun i => evalFractionRing (r i) x) = x i := by
  have : CharZero K := RingHom.charZero (algebraMap K ‚ÑÇ)
  have := (bijective_of_injective_on_isAlgClosed (K := FractionRing (MvPolynomial Œπ K))
    (L := AlgebraicClosure (FractionRing (MvPolynomial Œπ K))) (Œπ := Œπ)
    (fun i => (p i).map (algebraMap _ _))
    (by
      let : Algebra K (AlgebraicClosure (FractionRing (MvPolynomial Œπ K))) :=
        Algebra.compHom _ (algebraMap K (FractionRing (MvPolynomial Œπ K)))
      have : (algebraMap (FractionRing (MvPolynomial Œπ K)) (AlgebraicClosure (FractionRing (MvPolynomial Œπ K)))).comp
        (algebraMap K ((FractionRing (MvPolynomial Œπ K)))) = algebraMap _ _ := rfl
      simp only [aeval_def, ‚Üê eval_map, map_map, this]
      simp only [eval_map, ‚Üê aeval_def]
      simpa [injective_iff_mem_radical] using hInj)).2
    (fun i => algebraMap (MvPolynomial Œπ K) _ (MvPolynomial.X i))
  rcases this with ‚ü®r, hr‚ü©
  have hInj': Function.Injective (fun x i => eval x ((p i).map (algebraMap K ‚ÑÇ ))) := by
    convert hInj; simp [aeval_def]
  simp only [eval_map, ‚Üê aeval_def] at hr
  use r
  intro x hx i
  rw [‚Üê evalFractionRing_aeval _ _ _ hx]
  simp only [funext_iff] at hr
  rw [hr]
  rw [evalFractionRing_X]
